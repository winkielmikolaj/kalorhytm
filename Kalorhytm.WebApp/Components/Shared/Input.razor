@* Reusable Input Component
   Features:
   - Consistent styling
   - Label and error message support
   - Focus states
*@

<div class="mb-4">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label class="block text-sm font-medium text-gray-300 mb-2">@Label</label>
    }
    <input type="@InputType" 
           value="@Value"
           @onchange="HandleChange"
           @oninput="@(OnInput.HasDelegate ? OnInput : EventCallback<ChangeEventArgs>.Empty)"
           placeholder="@Placeholder"
           class="@GetInputClasses()"
           disabled="@IsDisabled" />
    @if (!string.IsNullOrEmpty(ErrorMessage))
    {
        <p class="mt-1 text-sm text-red-400">@ErrorMessage</p>
    }
</div>

@code {
    [Parameter] public string? Label { get; set; }
    [Parameter] public string? Placeholder { get; set; }
    [Parameter] public string? Value { get; set; }
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public EventCallback<ChangeEventArgs> OnInput { get; set; }
    [Parameter] public string InputType { get; set; } = "text";
    [Parameter] public bool IsDisabled { get; set; }
    [Parameter] public string? ErrorMessage { get; set; }
    [Parameter] public string AdditionalClass { get; set; } = "";

    private string GetInputClasses()
    {
        var baseClasses = "w-full bg-gray-600 text-white rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-700 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed";
        return $"{baseClasses} {AdditionalClass}";
    }

    private async Task HandleChange(ChangeEventArgs e)
    {
        Value = e.Value?.ToString() ?? string.Empty;
        if (ValueChanged.HasDelegate)
        {
            await ValueChanged.InvokeAsync(Value);
        }
    }
}

